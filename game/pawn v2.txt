from game.env_var import *
from game.mouvement import Mouvement
import numpy as np
import copy


class Pawn:
    """
    Classe représentant un pion dans le jeu.
    Chaque pion a une position (x,y), un type (1-4), un mouvement et une couleur.
    """

    def __init__(self, x, y, type, mouvement, color):
        """
        Initialise un pion avec ses attributs.
        """
        self.x = x
        self.y = y
        if type < 5:  # Vérification que le type est valide
            self.type = type
        self.mouvement = mouvement
        self.color = color

    def move(self, x, y, grid, allpawns, game, simulate=False):
        """
        Déplace le pion vers une nouvelle position.

        Returns:
            [bool, bool]: [Mouvement réussi, Victoire]
        """
        # Si la pile actuelle contient déjà 4 pions, impossible de bouger
        if len(grid[self.y][self.x]) == 4:
            return [False, False]

        # Vérifier si le mouvement est hors de la grille ou sur place
        if x < 0 or x >= len(grid.grid) or y < 0 or y >= len(grid.grid) or (self.x == x and self.y == y):
            return [False, False]

        # Phase normale du jeu
        if not game.initializing:
            # Vérifier si le mouvement est légal
            if Mouvement.legit_mouv(self, self, x, y, grid):
                # Calculer la nouvelle pile après le mouvement
                grid.grid[y][x] = self.stack(x, y, grid, allpawns)
                self.x = x
                self.y = y

                if not simulate:
                    grid.display()

                # Vérifier si le jeu est gagné (pile de 4)
                if len(grid.grid[y][x]) == 4:
                    return [True, True]
                else:
                    return [True, False]
            else:
                if not simulate:
                    print("Cant move there")
                    print("pawn moves", self.mouvement)
                return [False, False]
        # Phase d'initialisation du jeu
        else:
            # Vérifier si le placement est valide (ligne de départ selon la couleur)
            if (y == 0 and self.color == "blue") or (y == 4 and self.color == "orange"):
                grid.grid[y][x] = np.array([self.type])
                self.x = x
                self.y = y

                if not simulate:
                    grid.display()

                return [True, False]
            else:
                if not simulate:
                    print("Cant move there")
                    print("pawn moves", self.mouvement)
                return [False, False]

    def display(self):
        """
        Affiche les informations du pion.
        """
        print(f"-Pawn {self.color} {self.type} -  x: {self.x}, y: {self.y}, mouvement: {self.mouvement}")

    def stack(self, x, y, grid, allpawns):
        """
        Gère l'empilement des pions lors d'un mouvement.

        Returns:
            numpy.array: Nouvelle pile à la position de destination
        """
        # CAS 1: Déplacement partiel d'une pile (le pion n'est pas en haut de la pile)
        if len(grid[self.y][self.x]) > 1 and self.type != grid[self.y][self.x][0]:
            # Trouver l'index du pion dans la pile
            tmpid = 0
            for id in range(len(grid[self.y][self.x])):
                if grid[self.y][self.x][id] == self.type:
                    tmpid = id

            # Séparer la pile en deux parties
            stayingarr = grid[self.y][self.x].copy()

            # Préparer la pile de destination
            if grid[y][x][-1] != 0:
                goingarr = grid[y][x]
            else:
                goingarr = np.array([], dtype=int)

            # Déplacer les pions de la pile actuelle vers la pile de destination
            for i in range(tmpid, len(grid[self.y][self.x])):
                if i == tmpid:
                    goingarr = np.append(goingarr, stayingarr[i])
                    stayingarr = np.delete(stayingarr, i)
                else:
                    goingarr = np.append(goingarr, stayingarr[i-1])
                    stayingarr = np.delete(stayingarr, i-1)

            # Mettre à jour les piles sur la grille
            grid[self.y][self.x] = stayingarr
            grid[y][x] = goingarr

            # Mettre à jour les positions des pions
            pawnstomove = []
            pawnstostay = []
            tmpxy = [self.x, self.y]

            for pawn in allpawns:
                if pawn.type in goingarr and pawn.x == self.x and pawn.y == self.y:
                    pawnstomove.append(pawn)
                if pawn.type in stayingarr and pawn.x == self.x and pawn.y == self.y:
                    pawnstostay.append(pawn)

            for pawn in pawnstomove:
                pawn.x = x
                pawn.y = y

            for pawn in pawnstostay:
                pawn.x = tmpxy[0]
                pawn.y = tmpxy[1]

            return goingarr

        # CAS 2: Déplacement d'une pile entière et fusion avec une pile existante
        elif len(grid[self.y][self.x]) > 1 and grid[y][x][-1] > self.type and self.type == grid[self.y][self.x][0]:
            pawns = []
            currentstack = grid[self.y][self.x]
            stack = grid[y][x]

            # Vider la case de départ
            grid[self.y][self.x] = np.array([0])

            # Fusionner les piles
            for pawn in currentstack:
                stack = np.append(stack, pawn)

            # Mettre à jour les positions des pions
            for pawn in allpawns:
                if np.isin(pawn.type, currentstack) and pawn.x == self.x and pawn.y == self.y:
                    pawns.append(pawn)

            for pawn in pawns:
                pawn.x = x
                pawn.y = y

            return stack

        # CAS 3: Déplacement d'une pile entière vers une case vide
        elif len(grid[self.y][self.x]) > 1 and self.type == grid[self.y][self.x][0]:
            tmparr = grid[self.y][self.x]
            pawns = []

            # Vider la case de départ
            grid[self.y][self.x] = np.array([0])

            # Mettre à jour les positions des pions
            for pawn in allpawns:
                if np.isin(pawn.type, tmparr) and pawn.x == self.x and pawn.y == self.y:
                    pawns.append(pawn)

            for pawn in pawns:
                pawn.x = x
                pawn.y = y

            return tmparr

        # CAS 4: Déplacement d'un pion seul vers une case vide
        elif np.array_equal(grid[y][x], np.array([0])) and len(grid[self.y][self.x]) <= 1:
            grid[self.y][self.x] = np.array([0])
            return np.array([self.type])

        # CAS 5: Déplacement d'un pion seul et fusion avec une pile existante
        elif grid[y][x][-1] > self.type:
            grid[self.y][self.x] = np.array([0])
            return np.append(grid[y][x], self.type)

        else:
            print("Cant move there definitely don't")
            return 0