from game.env_var import *

class Mouvement:
    """
    Classe gérant les règles de déplacement des pions.
    Vérifie si un mouvement est légal selon le type de mouvement du pion.
    """

    @staticmethod
    def legit_mouv(pawn, pawn2, x, y, grid):
        """Vérifie si un mouvement est légal"""
        # Vérifier que la destination est dans la grille
        if x < 0 or x >= len(grid.grid) or y < 0 or y >= len(grid.grid):
            return False

        # Vérifier que le pion ne reste pas sur place
        if x == pawn.x and y == pawn.y:
            return False

        # Vérifier que le pion peut se poser sur la destination
        if len(grid.grid[y][x]) > 0 and grid.grid[y][x][0] != 0 and grid.grid[y][x][0] <= pawn.type:
            return False

        # Calculer la distance
        dx = abs(pawn.x - x)
        dy = abs(pawn.y - y)

        # Vérifier le type de mouvement
        if pawn.mouvement == "L":
            # Mouvement en L: 2 cases dans une direction, 1 dans l'autre
            return (dx == 2 and dy == 1) or (dx == 1 and dy == 2)

        elif pawn.mouvement == "+":
            # Mouvement en +: horizontal ou vertical
            if (dx > 0 and dy == 0) or (dx == 0 and dy > 0):
                # Vérifier que le chemin est libre
                if dy == 0:  # Horizontal
                    start_x = min(pawn.x, x) + 1
                    end_x = max(pawn.x, x)
                    for i in range(start_x, end_x):
                        if grid.grid[y][i][0] != 0:
                            return False
                else:  # Vertical
                    start_y = min(pawn.y, y) + 1
                    end_y = max(pawn.y, y)
                    for i in range(start_y, end_y):
                        if grid.grid[i][x][0] != 0:
                            return False
                return True
            return False

        elif pawn.mouvement == "X":
            # Mouvement en X: diagonal
            if dx == dy and dx > 0:
                # Vérifier que le chemin est libre
                x_step = 1 if x > pawn.x else -1
                y_step = 1 if y > pawn.y else -1
                cx, cy = pawn.x + x_step, pawn.y + y_step

                while cx != x and cy != y:
                    if grid.grid[cy][cx][0] != 0:
                        return False
                    cx += x_step
                    cy += y_step
                return True
            return False

        elif pawn.mouvement == "*":
            # Mouvement en *: horizontal, vertical ou diagonal
            if (dx > 0 and dy == 0) or (dx == 0 and dy > 0) or (dx == dy and dx > 0):
                # Vérifier que le chemin est libre
                if dy == 0:  # Horizontal
                    start_x = min(pawn.x, x) + 1
                    end_x = max(pawn.x, x)
                    for i in range(start_x, end_x):
                        if grid.grid[y][i][0] != 0:
                            return False
                elif dx == 0:  # Vertical
                    start_y = min(pawn.y, y) + 1
                    end_y = max(pawn.y, y)
                    for i in range(start_y, end_y):
                        if grid.grid[i][x][0] != 0:
                            return False
                else:  # Diagonal
                    x_step = 1 if x > pawn.x else -1
                    y_step = 1 if y > pawn.y else -1
                    cx, cy = pawn.x + x_step, pawn.y + y_step

                    while cx != x and cy != y:
                        if grid.grid[cy][cx][0] != 0:
                            return False
                        cx += x_step
                        cy += y_step
                return True
            return False

        return False
    

    @staticmethod
    def _check_L_movement(dx, dy):
        """
        Vérifie si un mouvement en L est légal.
        """
        return (dx == 2 and dy == 1) or (dx == 1 and dy == 2)

    @staticmethod
    def _check_plus_movement(pawn, x, y, dx, dy, grid):
        """
        Vérifie si un mouvement en + est légal.
        """
        # Le mouvement doit être horizontal ou vertical
        if not ((dx > 0 and dy == 0) or (dx == 0 and dy > 0)):
            return False

        # Vérifier qu'il n'y a pas d'obstacle sur le chemin
        if dx == 0:  # Mouvement vertical
            start_y = min(pawn.y, y) + 1
            end_y = max(pawn.y, y)
            for i in range(start_y, end_y):
                if grid.grid[i][x][-1] != 0:
                    return False
        else:  # Mouvement horizontal
            start_x = min(pawn.x, x) + 1
            end_x = max(pawn.x, x)
            for i in range(start_x, end_x):
                if grid.grid[y][i][-1] != 0:
                    return False

        return True

    @staticmethod
    def _check_X_movement(pawn, x, y, dx, dy, grid):
        """
        Vérifie si un mouvement en X est légal.
        """
        # Le mouvement doit être diagonal
        if dx != dy:
            return False

        # Déterminer la direction du mouvement
        x_step = 1 if x > pawn.x else -1
        y_step = 1 if y > pawn.y else -1

        # Vérifier qu'il n'y a pas d'obstacle sur le chemin
        current_x = pawn.x + x_step
        current_y = pawn.y + y_step

        while current_x != x and current_y != y:
            if grid.grid[current_y][current_x][-1] != 0 and pawn.type >= grid.grid[current_y][current_x][-1]:
                return False
            current_x += x_step
            current_y += y_step

        return True

    @staticmethod
    def _check_star_movement(pawn, x, y, dx, dy, grid):
        """
        Vérifie si un mouvement en * est légal.
        """
        # Le mouvement doit être horizontal, vertical ou diagonal
        if not ((dx > 0 and dy == 0) or (dx == 0 and dy > 0) or (dx == dy)):
            return False

        # Vérifier selon le type de mouvement
        if dx == 0 or dy == 0:  # Mouvement horizontal ou vertical
            return Mouvement._check_plus_movement(pawn, x, y, dx, dy, grid)
        else:  # Mouvement diagonal
            # Déterminer la direction du mouvement
            x_step = 1 if x > pawn.x else -1
            y_step = 1 if y > pawn.y else -1

            # Vérifier qu'il n'y a pas de pion de type 1 sur le chemin
            current_x = pawn.x + x_step
            current_y = pawn.y + y_step

            while current_x != x and current_y != y:
                if grid.grid[current_y][current_x][-1] == 1:
                    return False
                current_x += x_step
                current_y += y_step

            return True