import os
from data.data_manager import DataManager
from game.env_var import *
from game.game import Game
from ai.Minimax import Minimax
from ai.dummyAI import Dummyai
import csv
from datetime import datetime

# Paramètres du jeu
manual_mode = True    # True: placement manuel des pions, False: placement aléatoire
use_ai = True         # True: utiliser l'IA, False: jouer manuellement
ai_types = (1, 1)     # Types d'IA: 1 pour Minimax, 2 pour IA aléatoire (DummyAI)


def main():
    """
    Fonction principale du programme.
    """
    # Initialiser le gestionnaire de données
    # Note: pour écraser un fichier CSV existant, définir le paramètre overwrite à True
    # et url au chemin du fichier à écraser
    data_manager = DataManager(False, "./data/dataset/game_RR.csv")

    # Initialiser le jeu
    # Note: quand manual_mode est False et use_ai est True, nous devons définir ai_types à 1 pour
    # Minimax et 2 pour l'IA aléatoire
    game = Game(data_manager, manual_mode, use_ai, ai_types)

    # Obtenir l'heure actuelle
    start_time = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Nombre de parties à jouer
    loop = 1
    while loop > 0:
        if loop < 500:
            game.reset()
            print(loop)
            loop -= 1

        is_ai = game.use_ai
        counter = 0
        color = ""
        ispawnmoved = False

        # Initialiser les IA si nécessaire
        if game.use_ai:
            # Sélectionner les types d'IA en fonction des paramètres
            if game.ai_types[0] == 1 and game.ai_types[1] == 1:
                aiblue = Minimax("blue", game)
                aiorange = Minimax("orange", game)
            elif game.ai_types[0] == 1 and game.ai_types[1] == 2:
                aiblue = Minimax("blue", game)
                aiorange = Dummyai("orange")
            elif game.ai_types[0] == 2 and game.ai_types[1] == 1:
                aiblue = Dummyai("blue")
                aiorange = Minimax("orange", game)
            elif game.ai_types[0] == 2 and game.ai_types[1] == 2:
                aiblue = Dummyai("blue")
                aiorange = Dummyai("orange")
            else:
                # Par défaut, utiliser Minimax
                aiblue = Minimax("blue", game)
                aiorange = Minimax("orange", game)

        # Créer un nouveau fichier CSV pour enregistrer les mouvements
        path = "./CSV/"
        os.makedirs(path, exist_ok=True)  # Créer le dossier s'il n'existe pas
        time_str = datetime.now().strftime('%Y%m%d_%H%M%S')
        move_log_filename = f"{path}game_moves_{time_str}.csv"

        with open(move_log_filename, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(["Color", "Pawn", "X", "Y", "Turn"])  # En-tête

        # Boucle principale du jeu
        while True:
            counterinit = 0

            # Vérifier si la grille est cassée
            if game.grid.isbroken:
                print("game is broken")
                print("Game ended in", counter, "turns")
                for pawn in game.pawns:
                    pawn.display()
                break

            # Vérifier si le dernier mouvement était une retraite
            with open(move_log_filename, mode='r', newline='') as file:
                moves = list(csv.reader(file))
                if len(moves) > 1:  # S'assurer qu'il y a au moins un mouvement
                    last_move = moves[-1]
                    if game.isretraite(last_move):
                        game.num_retreat += 1

            # Vérifier si le jeu est toujours en phase d'initialisation
            for pawn in game.pawns:
                if pawn.color == "blue" and pawn.y == 0:
                    counterinit += 1
                elif pawn.color == "orange" and pawn.y == 4:
                    counterinit += 1

            if counterinit == 8:
                print("finish initialisation of the game")
                game.initializing = False

            if game.initializing == False:
                game.grid.checkgrid(counter)

            # Déterminer le joueur actuel
            if counter % 2 == 0:
                color = "blue"
            else:
                color = "orange"

            # Obtenir les mouvements possibles
            game.all_next_moves(color)
            move = None

            # Obtenir le mouvement (IA ou humain)
            if game.use_ai:
                ai = aiblue if color == "blue" else aiorange

                if ai.type == "M":
                    print("MINMAX AI")
                    move = ai.playsmart()  # Obtenir le meilleur mouvement de l'IA

                    if move:
                        if move[1] == -1:  # Pas de mouvement valide
                            os.remove(move_log_filename)
                            loop += 1
                            break

                        print(f"AI {color} chooses to move pawn {move[1]} to ({move[2]}, {move[3]})")
                        # Mettre à jour l'historique du pion
                        data_manager.update_pawn_history(color, move[1], (move[2], move[3]), counter)
                else:
                    print("RANDOM AI")
                    move = ai.playrandom(game.all_next_moves(color))

                    try:
                        pawn_to_move = move[1]
                        x = move[2]
                        y = move[3]
                        print(f"RANDOMAI {color} chooses to move pawn {pawn_to_move} to ({x}, {y})")
                        # Mettre à jour l'historique du pion
                        data_manager.update_pawn_history(color, move[1], (move[2], move[3]), counter)
                    except:
                        print("No moves available")
                        game.grid.display()
                        loop = 0
                        break
            else:
                # Entrée utilisateur pour le mouvement
                try:
                    pawn_to_move = float(input("Select pawn:") or 1.)
                    x = int(input("x:") or 1.)
                    y = int(input("y:") or 1.)
                    move = [color, pawn_to_move, x, y]
                except:
                    print("Invalid input")
                    continue

            # Traiter le mouvement
            if move:
                pawn_to_move, x, y = move[1], move[2], move[3]

                if pawn_to_move == -1:
                    # Situation bloquante pour un joueur
                    break

                # Vérifier si le pion à déplacer est dans la liste des pions qui doivent jouer
                for pawn in game.pawns:
                    if pawn.type == pawn_to_move and pawn.color == color:
                        if pawns_must_play[color] == []:
                            ispawnmoved = pawn.move(x, y, game.grid, game.pawns, game)
                        else:
                            if pawn in pawns_must_play[color]:
                                ispawnmoved = pawn.move(x, y, game.grid, game.pawns, game)
                                pawns_must_play[color].remove(pawn)
                            else:
                                # Le pion n'est pas dans la zone de retraite
                                ispawnmoved = [False, False]

                if ispawnmoved[0]:
                    # Enregistrer le mouvement dans le fichier CSV
                    with open(move_log_filename, mode='a', newline='') as file:
                        writer = csv.writer(file)
                        writer.writerow([color, pawn_to_move, x, y, counter])

                    # Vérifier si le jeu est gagné
                    if ispawnmoved[1]:
                        print("Game Over")
                        print("And the winner is....", color, "!!!")
                        print("Game ended in", counter, "turns")

                        # Obtenir la pile finale
                        final_stack = game.grid.getfinalstack(x, y)

                        # Informations sur les IA
                        ai = [
                            {"type": aiblue.type,
                             "depth": aiblue.base_depth if aiblue.type == "M" else None,
                             "color": "BLUE"},
                            {"type": aiorange.type,
                             "depth": aiorange.base_depth if aiorange.type == "M" else None,
                             "color": "ORANGE"}
                        ]

                        # Enregistrer les résultats
                        data_manager.write(ai, color, counter, game.num_retreat, final_stack)
                        game.winner = color

                        # Nettoyer le fichier de log
                        os.remove(move_log_filename)
                        break

                # Incrémenter le compteur si le joueur a joué un mouvement valide
                if ispawnmoved[0]:
                    counter += 1

        # Calculer la durée de la partie
        end_time = datetime.now().strftime("%Y%m%d_%H%M%S")
        duration = datetime.strptime(end_time, "%Y%m%d_%H%M%S") - datetime.strptime(start_time, "%Y%m%d_%H%M%S")
        print("Duration:", duration)


if __name__ == "__main__":
    main()